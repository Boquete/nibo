From 555ec66f05c4681b996a72b1dc24dc07133ada1a Mon Sep 17 00:00:00 2001
From: Alex Kocharin <alex@kocharin.ru>
Date: Wed, 18 Apr 2012 02:45:58 +0400
Subject: [PATCH 1/2] encoding support

Rebased and documented by @noraesae
---
 docs/API.rst | 11 ++++++++++-
 lib/irc.js   | 30 +++++++++++++++++++++++++-----
 2 files changed, 35 insertions(+), 6 deletions(-)

diff --git a/docs/API.rst b/docs/API.rst
index 296c6cb..44d38e9 100644
--- a/docs/API.rst
+++ b/docs/API.rst
@@ -31,7 +31,8 @@ Client
             floodProtectionDelay: 1000,
             stripColors: false,
             channelPrefixes: "&#",
-            messageSplit: 512
+            messageSplit: 512,
+            encoding: false
         }

     `secure` (SSL connection) can be a true value or an object (the kind of object
@@ -55,6 +56,14 @@ Client
     bold, 0x1f underline, 0x16 reverse, 0x0f reset) from the entire
     message before parsing it and passing it along.

+    `encoding` can be any encoding acceptable to iconv, for example,
+    'ASCII', 'CP1251//IGNORE', 'CP949', etc. You can also check acceptable
+    encodings with a console command, 'iconv -l'. Setting `encoding` to
+    false(default) means that you use default encoding, UTF-8. If you don't
+    use default encoding, you need to install node-iconv module::
+
+        npm install iconv
+
     Setting `autoConnect` to false prevents the Client from connecting on
     instantiation.  You will need to call `connect()` on the client instance::

diff --git a/lib/irc.js b/lib/irc.js
index 59fad36..b978ab3 100644
--- a/lib/irc.js
+++ b/lib/irc.js
@@ -50,7 +50,8 @@ function Client(server, nick, opt) {
         floodProtectionDelay: 1000,
         stripColors: false,
         channelPrefixes: "&#",
-        messageSplit: 512
+        messageSplit: 512,
+        encoding: false
     };

     // Features supported by the server
@@ -86,6 +87,18 @@ function Client(server, nick, opt) {
         self.activateFloodProtection();
     }

+    if (self.opt.encoding) {
+        var Iconv = require('iconv').Iconv;
+        var from = new Iconv(self.opt.encoding, 'UTF-8');
+        var to = new Iconv('UTF-8', self.opt.encoding);
+        self.encode = function(str) {
+            return to.convert(str);
+        }
+        self.decode = function(str) {
+            return from.convert(str);
+        }
+    }
+
     // TODO - fail if nick or server missing
     // TODO - fail if username has a space in it
     if (self.opt.autoConnect === true) {
@@ -589,7 +602,7 @@ Client.prototype.connect = function ( retryCount, callback ) { // {{{
                 (self.opt.certExpired &&
                    self.conn.authorizationError === 'CERT_HAS_EXPIRED')) {
               // authorization successful
-              self.conn.setEncoding('utf-8');
+              if (!self.opt.encoding) self.conn.setEncoding('utf-8');
                 if ( self.opt.certExpired &&
                    self.conn.authorizationError === 'CERT_HAS_EXPIRED' ) {
                      util.log('Connecting to server with expired certificate');
@@ -612,7 +625,7 @@ Client.prototype.connect = function ( retryCount, callback ) { // {{{
     }
     self.conn.requestedDisconnect = false;
     self.conn.setTimeout(0);
-    self.conn.setEncoding('utf8');
+    if (!self.opt.encoding) self.conn.setEncoding('utf-8');
     self.conn.addListener("connect", function () {
         if ( self.opt.password !==  null ) {
             self.send( "PASS", self.opt.password );
@@ -624,7 +637,8 @@ Client.prototype.connect = function ( retryCount, callback ) { // {{{
     });
     var buffer = '';
     self.conn.addListener("data", function (chunk) {
-        buffer += chunk;
+        // it's source of bugs if original encoding is multibyte and message is large
+        buffer += self.decode(chunk);
         var lines = buffer.split("\r\n");
         buffer = lines.pop();
         lines.forEach(function (line) {
@@ -698,7 +712,7 @@ Client.prototype.send = function(command) { // {{{
         util.log('SEND: ' + command + " " + args.join(" "));

     if ( ! this.conn.requestedDisconnect ) {
-        this.conn.write(command + " " + args.join(" ") + "\r\n");
+        this.conn.write(this.encode(command + " " + args.join(" ") + "\r\n"));
     }
 }; // }}}
 Client.prototype.activateFloodProtection = function(interval) { // {{{
@@ -783,6 +797,12 @@ Client.prototype.action = function(channel, text) { // {{{
 Client.prototype.notice = function(target, text) { // {{{
     this.send('NOTICE', target, text);
 } // }}}
+Client.prototype.encode = function(str) { // {{{
+    return str;
+} // }}}
+Client.prototype.decode = function(str) { // {{{
+    return str;
+} // }}}
 Client.prototype.whois = function(nick, callback) { // {{{
     if ( typeof callback === 'function' ) {
         var callbackWrapper = function(info) {
--
1.9.1


From 639432c9bcc769f7df432e4a2dd98c0c5d61d474 Mon Sep 17 00:00:00 2001
From: HyeonJe Jun <noraesae@company100.net>
Date: Fri, 26 Oct 2012 19:00:39 +0900
Subject: [PATCH 2/2] Process decoding after all the chunks have been received.

Prevent bugs that can occur when decode the large chunk with
multibyte encoding.
---
 lib/irc.js | 23 ++++++++++++++++++-----
 1 file changed, 18 insertions(+), 5 deletions(-)

diff --git a/lib/irc.js b/lib/irc.js
index b978ab3..1fa33ee 100644
--- a/lib/irc.js
+++ b/lib/irc.js
@@ -635,12 +635,25 @@ Client.prototype.connect = function ( retryCount, callback ) { // {{{
         self.send("USER", self.opt.userName, 8, "*", self.opt.realName);
         self.emit("connect");
     });
-    var buffer = '';
+    var buffer = new Buffer('');
     self.conn.addListener("data", function (chunk) {
-        // it's source of bugs if original encoding is multibyte and message is large
-        buffer += self.decode(chunk);
-        var lines = buffer.split("\r\n");
-        buffer = lines.pop();
+        if(typeof(chunk) == 'string') {
+            buffer += chunk;
+        }
+        else {
+            buffer = Buffer.concat([buffer, chunk]);
+        }
+
+        var lines = self.decode(buffer).toString().split("\r\n");
+        if( lines.pop() ) {
+            // if buffer is not ended with \r\n, there's more chunks.
+            return;
+        }
+        else {
+            // else, initialize the buffer.
+            buffer = new Buffer('');
+        }
+
         lines.forEach(function (line) {
             var message = parseMessage(line, self.opt.stripColors);
             try {
--
1.9.1

